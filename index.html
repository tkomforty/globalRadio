<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Radio Listener</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic reset and body styling */
        body { margin: 0; overflow: hidden; background-color: #111827; color: #f3f4f6; font-family: 'Inter', sans-serif; }
        /* Container for the 3D canvas */
        #container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
        }
        /* 2D visualizer canvas (behind globe) */
        #visualizerCanvas {
            position: absolute; top: 50%; transform: translateY(-50%); left: 0;
            width: 100%; height: 150px; z-index: -1; pointer-events: none;
        }
        /* Overlay for UI elements */
        #uiOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
        }
        /* Info box styling */
        #infoBox {
            position: absolute; top: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.7); padding: 10px 15px; border-radius: 8px;
            color: white; font-size: 0.9rem; max-width: 300px; border: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 2px 10px rgba(0,0,0,0.5); pointer-events: auto;
        }
        #infoBox strong { display: block; margin-bottom: 5px; font-weight: 600; }
        #infoBox span { font-size: 0.8rem; opacity: 0.8; }
        /* Instructions styling */
        #instructions {
             position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); padding: 8px 12px; border-radius: 8px;
             color: white; font-size: 0.8rem; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; pointer-events: auto;
        }
        /* Loading message styling */
         #loadingMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.2rem; background-color: rgba(0, 0, 0, 0.8);
            padding: 20px; border-radius: 10px; z-index: 11; pointer-events: none;
        }
        /* Play/Pause button styling */
         #pauseButton {
            position: absolute; top: 20px; right: 20px; background-color: rgba(0, 0, 0, 0.6); color: white; border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; transition: background-color 0.2s ease;
        }
        #pauseButton:hover { background-color: rgba(0, 0, 0, 0.8); }
        #pauseButton:disabled { opacity: 0.5; cursor: not-allowed; }
        #pauseButton svg { width: 20px; height: 20px; fill: currentColor; }
        /* Ensure Three.js canvas displays correctly */
        canvas#threeCanvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-gray-100">

    <div id="container"></div>
    <canvas id="visualizerCanvas"></canvas>

    <div id="uiOverlay">
        <div id="infoBox" style="display: none;">
            <strong>Now Playing:</strong>
            <span id="stationName">Loading...</span>
        </div>
        <div id="instructions">
            Click & Drag to rotate. Click a marker to play radio.
        </div>
        <button id="pauseButton" title="Play/Pause" disabled>
             <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display: block;"> <path d="M8 5v14l11-7z"/> </svg>
             <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display: none;"> <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/> </svg>
        </button>
    </div>

    <div id="loadingMessage">Loading Radio Stations...</div>
    <audio id="audioPlayer" crossorigin="anonymous"></audio>

    <script type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants ---
        const API_BASE_URL = 'https://at1.api.radio-browser.info/json';
        const GENERAL_STATIONS_URL = `${API_BASE_URL}/stations/search?limit=350&has_geo_info=true&order=random&hidebroken=true&codec=MP3&codec=AAC`;
        const JAPAN_STATIONS_URL = `${API_BASE_URL}/stations/search?limit=50&countrycode=JP&has_geo_info=true&hidebroken=true&codec=MP3&codec=AAC`;
        const GLOBE_RADIUS = 5;
        const FFT_SIZE = 1024;
        const VISUALIZER_HEIGHT = 150;

        // --- DOM Elements ---
        const container = document.getElementById('container');
        const audioPlayer = document.getElementById('audioPlayer');
        const infoBox = document.getElementById('infoBox');
        const stationNameElement = document.getElementById('stationName');
        const loadingMessage = document.getElementById('loadingMessage');
        const pauseButton = document.getElementById('pauseButton');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const visualizerCanvas = document.getElementById('visualizerCanvas');
        const visualizerCtx = visualizerCanvas.getContext('2d');

        // --- Three.js Variables ---
        let scene, camera, renderer, controls;
        let globe, markersGroup;
        const raycaster = new THREE.Raycaster(); const pointer = new THREE.Vector2();
        let INTERSECTED; let selectedMarker = null;

        // --- Web Audio API Variables ---
        let audioContext; let analyser; let audioSource; let dataArray;
        let isAudioContextSetup = false; let lastCorsWarningTime = 0;

        // --- State ---
        let rafId;

        //========================================== Initialization ==========================================
        async function init() {
            console.log("Starting initialization..."); // Debug log
            loadingMessage.style.display = 'block';

            try {
                // Setup core Three.js and UI first
                setupScene();
                console.log("Scene setup complete."); // Debug log
                setupLighting();
                console.log("Lighting setup complete."); // Debug log
                setupControls();
                console.log("Controls setup complete."); // Debug log
                setupGlobe(); // Creates the globe mesh
                console.log("Globe setup complete."); // Debug log
                setupMarkersGroup(); // Creates the group for markers
                console.log("Markers group setup complete."); // Debug log
                setupEventListeners();
                console.log("Event listeners setup complete."); // Debug log

                // Fetch stations and add markers within a try-catch
                console.log("Fetching stations..."); // Debug log
                const allStations = await fetchAllStations();
                console.log(`Fetched ${allStations.length} stations total.`); // Debug log

                if (allStations.length > 0) {
                    addStationMarkers(allStations); // Adds markers to the group
                    console.log("Added station markers."); // Debug log
                } else {
                     console.warn("No stations loaded or fetch failed.");
                     if (loadingMessage.textContent.startsWith('Loading')) {
                         loadingMessage.textContent = 'No valid stations found.';
                     }
                     // Keep loading message visible if needed, or hide it
                     // loadingMessage.style.display = 'none'; // Decide if you want to hide it even on failure
                }

                // Hide loading message only after attempting to add markers
                loadingMessage.style.display = 'none';

                 console.log("Starting animation loop..."); // Debug log
                 animate(); // Start rendering loop

            } catch (error) {
                console.error("Error during initialization:", error);
                loadingMessage.textContent = 'Initialization Error. Please refresh.';
                loadingMessage.style.display = 'block'; // Ensure error is visible
            }
        }

        //========================================== Scene, Camera, Renderer, Canvas Setup ==========================================
        function setupScene() {
            scene = new THREE.Scene(); scene.background = null;
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 15;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            renderer.domElement.id = 'threeCanvas'; container.appendChild(renderer.domElement);
            visualizerCanvas.width = window.innerWidth; visualizerCanvas.height = VISUALIZER_HEIGHT;
        }

        //========================================== Lighting Setup ==========================================
        function setupLighting() {
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xaaaaaa, 1.5 ); scene.add( hemiLight );
            const ambientLight = new THREE.AmbientLight( 0xffffff, 1.0 ); scene.add( ambientLight );
        }

        //========================================== Controls Setup ==========================================
        function setupControls() {
             controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05;
             controls.screenSpacePanning = false; controls.enablePan = false; controls.minDistance = 7; controls.maxDistance = 50; controls.maxPolarAngle = Math.PI;
        }

        //========================================== Globe Setup ==========================================
        function setupGlobe() {
            const globeGeometry = new THREE.SphereGeometry(GLOBE_RADIUS, 64, 32);
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/textures/planets/earth_atmos_2048.jpg',
               () => console.log("Globe texture loaded successfully."),
               undefined,
               (err) => console.error('Failed to load globe texture:', err) // Log texture errors
            );
            earthTexture.colorSpace = THREE.SRGBColorSpace;
            const globeMaterial = new THREE.MeshStandardMaterial({ map: earthTexture, metalness: 0.1, roughness: 0.9, color: 0xffffff });
            globe = new THREE.Mesh(globeGeometry, globeMaterial);
            scene.add(globe); // Ensure globe is added to the scene
            console.log("Globe mesh added to scene:", globe); // Debug log
        }

        //========================================== Markers Group Setup ==========================================
        function setupMarkersGroup() { markersGroup = new THREE.Group(); globe.add(markersGroup); } // Markers are children of globe

        //========================================== Event Listeners Setup ==========================================
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize); window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('click', onClick); window.addEventListener('contextmenu', (event) => event.preventDefault());
            pauseButton.addEventListener('click', togglePlayback); audioPlayer.addEventListener('error', handleAudioError);
            audioPlayer.addEventListener('stalled', handleAudioStalled); audioPlayer.addEventListener('playing', handleAudioPlaying);
            audioPlayer.addEventListener('pause', handleAudioPaused); audioPlayer.addEventListener('ended', handleAudioEnded);
        }

        //========================================== Fetch Stations (Combined) ==========================================
        async function fetchAllStations() {
             // This function now has its own try-catch, which is good.
             // Ensure it returns [] on error so init can proceed.
             console.log("Fetching general and Japanese stations...");
             try {
                 const [generalResponse, japanResponse] = await Promise.all([
                     fetch(GENERAL_STATIONS_URL, { mode: 'cors' }),
                     fetch(JAPAN_STATIONS_URL, { mode: 'cors' })
                 ]);
                 // Added checks for ok status before parsing JSON
                 const generalData = generalResponse.ok ? await generalResponse.json() : [];
                 if (!generalResponse.ok) console.warn(`General stations fetch failed: ${generalResponse.status}`);
                 const japanData = japanResponse.ok ? await japanResponse.json() : [];
                 if (!japanResponse.ok) console.warn(`Japan stations fetch failed: ${japanResponse.status}`);

                 console.log(`Fetched ${generalData.length} general, ${japanData.length} Japanese stations raw.`);
                 const allStationsData = [...generalData, ...japanData];
                 const stationMap = new Map();
                 allStationsData.forEach(station => {
                     const url = station.url_resolved || station.url;
                     if (station.geo_lat != null && station.geo_long != null && typeof station.geo_lat === 'number' && typeof station.geo_long === 'number' && url && url.startsWith('https')) {
                         const key = station.stationuuid || url;
                         if (!stationMap.has(key)) {
                             stationMap.set(key, { name: (station.name || 'Unknown').replace(/</g, "&lt;").replace(/>/g, "&gt;"), lat: station.geo_lat, lon: station.geo_long, url: url, country: (station.countrycode || station.country || 'Unknown').replace(/</g, "&lt;").replace(/>/g, "&gt;"), favicon: station.favicon || null, codec: station.codec || 'Unknown' });
                         }
                     }
                 });
                 const uniqueStations = Array.from(stationMap.values());
                 console.log(`Processed ${uniqueStations.length} unique valid HTTPS stations.`);
                 logRegionalDistribution(uniqueStations); return uniqueStations;
             } catch (error) { console.error("Failed to fetch stations inside fetchAllStations:", error); return []; } // Return empty array on error
        }


        //========================================== Add Station Markers ==========================================
        function addStationMarkers(stationsData) {
             // Check if markersGroup exists before adding children
             if (!markersGroup) {
                 console.error("markersGroup not initialized before addStationMarkers!");
                 return;
             }
             const markerGeometry = new THREE.SphereGeometry(0.07, 12, 6); const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00, toneMapped: false });
             stationsData.forEach(station => {
                 const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone()); const phi = (90 - station.lat) * (Math.PI / 180); const theta = (station.lon + 180) * (Math.PI / 180);
                 marker.position.set(-(GLOBE_RADIUS * Math.sin(phi) * Math.cos(theta)), GLOBE_RADIUS * Math.cos(phi), GLOBE_RADIUS * Math.sin(phi) * Math.sin(theta));
                 marker.position.multiplyScalar(1.01); marker.lookAt(globe.position); marker.userData = station; markersGroup.add(marker);
             }); console.log(`Added ${markersGroup.children.length} markers to markersGroup.`);
        }

        //========================================== Web Audio API Setup ==========================================
        function setupAudioContext() {
             if (isAudioContextSetup) return; try {
                 console.log("Setting up Audio Context..."); audioContext = new (window.AudioContext || window.webkitAudioContext)();
                 analyser = audioContext.createAnalyser(); analyser.fftSize = FFT_SIZE;
                 const bufferLength = analyser.frequencyBinCount; dataArray = new Uint8Array(bufferLength);
                 audioSource = audioContext.createMediaElementSource(audioPlayer); audioSource.connect(analyser); analyser.connect(audioContext.destination);
                 isAudioContextSetup = true; console.log("Audio Context setup complete.");
             } catch (e) { console.error("Audio Context Error:", e); alert("Web Audio API init failed."); }
        }

        //========================================== Event Handlers ==========================================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            visualizerCanvas.width = window.innerWidth; visualizerCanvas.height = VISUALIZER_HEIGHT;
        }
        // ... other event handlers ...
        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera); const intersects = raycaster.intersectObjects(markersGroup.children);
            if (intersects.length > 0) { const firstIntersect = intersects[0].object; if (INTERSECTED !== firstIntersect) { if (INTERSECTED && INTERSECTED !== selectedMarker) INTERSECTED.material.color.setHex(0xffcc00); INTERSECTED = firstIntersect; if (INTERSECTED !== selectedMarker) INTERSECTED.material.color.setHex(0x00ff00); document.body.style.cursor = 'pointer'; } }
            else { if (INTERSECTED && INTERSECTED !== selectedMarker) INTERSECTED.material.color.setHex(0xffcc00); INTERSECTED = null; document.body.style.cursor = 'default'; }
        }
        function onClick(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera); const intersects = raycaster.intersectObjects(markersGroup.children);
            if (intersects.length > 0) {
                const clickedMarker = intersects[0].object; if (audioContext && audioContext.state === 'suspended') audioContext.resume();
                if (clickedMarker === selectedMarker) { togglePlayback(); return; } if (!isAudioContextSetup) setupAudioContext();
                if (selectedMarker) { selectedMarker.material.color.setHex(0xffcc00); selectedMarker.scale.set(1, 1, 1); }
                selectedMarker = clickedMarker; selectedMarker.material.color.setHex(0xff0000); const station = selectedMarker.userData;
                console.log(`Playing: ${station.name} (${station.country}), Codec: ${station.codec}, URL: ${station.url}`);
                stationNameElement.textContent = `${station.name} (${station.country}) - Loading...`; infoBox.style.display = 'block'; pauseButton.disabled = true;
                audioPlayer.src = station.url; audioPlayer.load(); audioPlayer.play().then(() => console.log("Playback initiated")).catch(error => console.error("Play() failed:", error));
            }
        }
        function togglePlayback() {
            if (!selectedMarker) return; if (audioPlayer.paused) { if (audioContext && audioContext.state === 'suspended') audioContext.resume(); audioPlayer.play().catch(handleAudioError); } else { audioPlayer.pause(); }
        }
        function updatePauseButton() {
            if (!selectedMarker) { pauseButton.disabled = true; playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; return; }
            pauseButton.disabled = false; if (audioPlayer.paused) { playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; pauseButton.title = "Play"; } else { playIcon.style.display = 'none'; pauseIcon.style.display = 'block'; pauseButton.title = "Pause"; }
        }
        function handleAudioError(e) {
             console.error('Audio Error:', e); const currentStationName = selectedMarker?.userData?.name || 'station'; let errorDetails = 'Stream offline/incompatible.';
             if (audioPlayer.error) { switch (audioPlayer.error.code) { case MediaError.MEDIA_ERR_ABORTED: errorDetails = 'Aborted.'; break; case MediaError.MEDIA_ERR_NETWORK: errorDetails = 'Network error.'; break; case MediaError.MEDIA_ERR_DECODE: errorDetails = 'Decode error.'; break; case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorDetails = 'Format/blocked (CORS?).'; break; default: errorDetails = `Unknown (${audioPlayer.error.code}).`; } }
             const codecInfo = selectedMarker?.userData?.codec ? ` (${selectedMarker.userData.codec})` : ''; stationNameElement.textContent = `Error: ${currentStationName}${codecInfo}. ${errorDetails}`; infoBox.style.display = 'block';
             if (selectedMarker) { selectedMarker.material.color.setHex(0xffcc00); selectedMarker.scale.set(1, 1, 1); selectedMarker = null; } updatePauseButton();
        }
        function handleAudioStalled() { console.warn('Audio stalled'); if (selectedMarker) { stationNameElement.textContent = `Buffering: ${selectedMarker.userData.name} (${selectedMarker.userData.country})`; infoBox.style.display = 'block'; } }
        function handleAudioPlaying() { console.log('Audio playing'); if (selectedMarker) { stationNameElement.textContent = `${selectedMarker.userData.name} (${selectedMarker.userData.country})`; infoBox.style.display = 'block'; } updatePauseButton(); }
        function handleAudioPaused() { console.log('Audio paused'); updatePauseButton(); }
        function handleAudioEnded() { console.log('Audio ended'); if (selectedMarker) { selectedMarker.material.color.setHex(0xffcc00); selectedMarker.scale.set(1, 1, 1); selectedMarker = null; } stationNameElement.textContent = 'Stream ended.'; infoBox.style.display = 'block'; updatePauseButton(); }


        //========================================== Animation Loop & Visualization ==========================================
        function animate() {
            // Ensure animate is only called once via requestAnimationFrame
            rafId = requestAnimationFrame(animate);

            controls.update(); // Update controls first

            // Update marker pulse effect
            if (selectedMarker && !audioPlayer.paused) { const time = Date.now() * 0.005; const scaleFactor = 0.15 * Math.abs(Math.sin(time)); selectedMarker.scale.set(1 + scaleFactor, 1 + scaleFactor, 1 + scaleFactor); }
            else if (selectedMarker && selectedMarker.scale.x !== 1) { selectedMarker.scale.set(1, 1, 1); }

            // Draw 2D visualizer
            drawVisualizer();

            // Render the scene
            try {
                 renderer.render(scene, camera);
            } catch (renderError) {
                 console.error("Error during render:", renderError);
                 // Optionally cancel animation loop on render error
                 // cancelAnimationFrame(rafId);
            }
        }

        function drawVisualizer() {
            if (!isAudioContextSetup || !analyser) { visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height); return; }
             visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            if (audioPlayer.paused) { return; }
            analyser.getByteTimeDomainData(dataArray);
            let isFlat = true; for(let i = 0; i < analyser.frequencyBinCount; i++) { if (dataArray[i] !== 128) { isFlat = false; break; } }
            if (isFlat && Date.now() - lastCorsWarningTime > 10000) { console.warn("Visualizer data flat (CORS?)."); lastCorsWarningTime = Date.now(); }
            const sliceWidth = visualizerCanvas.width * 1.0 / analyser.frequencyBinCount; const canvasHeight = visualizerCanvas.height; const centerY = canvasHeight / 2;
            const offsets = [-15, 0, 15]; const colors = ['rgba(0, 220, 255, 0.3)', 'rgba(59, 130, 246, 0.9)', 'rgba(0, 220, 255, 0.3)']; const lineWidths = [1, 2, 1];
            for(let lineIndex = 0; lineIndex < offsets.length; lineIndex++) {
                visualizerCtx.lineWidth = lineWidths[lineIndex]; visualizerCtx.strokeStyle = colors[lineIndex]; visualizerCtx.beginPath(); let x = 0;
                for (let i = 0; i < analyser.frequencyBinCount; i++) {
                    const v = dataArray[i] / 128.0; const y = (v * centerY / 2) + centerY + offsets[lineIndex];
                    if (i === 0) visualizerCtx.moveTo(x, y); else visualizerCtx.lineTo(x, y);
                    x += sliceWidth;
                }
                visualizerCtx.lineTo(visualizerCanvas.width, centerY + offsets[lineIndex]); visualizerCtx.stroke();
            }
        }

        //========================================== Utility Functions ==========================================
        function logRegionalDistribution(stations) {
             const regions = { Africa: 0, Asia: 0, Europe: 0, NorthAmerica: 0, SouthAmerica: 0, Oceania: 0, Other: 0, Japan: 0 };
             stations.forEach(s => {
                 if (s.country === 'JP') regions.Japan++;
                 else if (s.lon > -20 && s.lon < 60 && s.lat > -40 && s.lat < 40) regions.Africa++;
                 else if (s.lon > 60 && s.lon < 180 && s.lat > -10) regions.Asia++;
                 else if (s.lon > -10 && s.lon < 40 && s.lat > 35) regions.Europe++;
                 else if (s.lon > -170 && s.lon < -50 && s.lat > 10) regions.NorthAmerica++;
                 else if (s.lon > -90 && s.lon < -30 && s.lat < 10) regions.SouthAmerica++;
                 else if (s.lon > 110 && s.lon < 180 && s.lat < -10) regions.Oceania++;
                 else regions.Other++;
             });
             console.log("Approximate regional distribution:", regions);
        }

        //========================================== Start Application ==========================================
        init(); // Call init to start everything

    </script>

</body>
</html>
