<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Radio Listener</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic reset and body styling */
        body { margin: 0; overflow: hidden; background-color: #111827; color: #f3f4f6; font-family: 'Inter', sans-serif; }
        /* Container for the 3D canvas */
        #container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;
        }
        /* 2D visualizer canvas (behind globe) */
        #visualizerCanvas {
            position: absolute; top: 50%; transform: translateY(-50%); left: 0;
            width: 100%; height: 150px; z-index: -1; pointer-events: none;
        }
        /* Overlay for UI elements */
        #uiOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
        }
        /* Info box styling */
        #infoBox {
            position: absolute; top: 20px; left: 20px; background-color: rgba(0, 0, 0, 0.7); padding: 10px 15px; border-radius: 8px;
            color: white; font-size: 0.9rem; max-width: 300px; border: 1px solid rgba(255, 255, 255, 0.2); box-shadow: 0 2px 10px rgba(0,0,0,0.5); pointer-events: auto;
        }
        #infoBox strong { display: block; margin-bottom: 5px; font-weight: 600; }
        #infoBox span { font-size: 0.8rem; opacity: 0.8; }
        /* Instructions styling */
        #instructions {
             position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); padding: 8px 12px; border-radius: 8px;
             color: white; font-size: 0.8rem; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; pointer-events: auto;
        }
        /* Loading message styling */
         #loadingMessage {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.2rem; background-color: rgba(0, 0, 0, 0.8);
            padding: 20px; border-radius: 10px; z-index: 11; pointer-events: none;
        }
        /* Play/Pause button styling */
         #pauseButton {
            position: absolute; top: 20px; right: 20px; background-color: rgba(0, 0, 0, 0.6); color: white; border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; transition: background-color 0.2s ease;
        }
        #pauseButton:hover { background-color: rgba(0, 0, 0, 0.8); }
        #pauseButton:disabled { opacity: 0.5; cursor: not-allowed; }
        #pauseButton svg { width: 20px; height: 20px; fill: currentColor; }
        /* Loading spinner */
        #pauseButton .loading-spinner {
            display: none;
            animation: spin 1s linear infinite;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Ensure Three.js canvas displays correctly */
        canvas#threeCanvas { display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-gray-100">

    <div id="container"></div>
    <canvas id="visualizerCanvas"></canvas>

    <div id="uiOverlay">
        <div id="infoBox" style="display: none;">
            <strong>Now Playing:</strong>
            <span id="stationName">Loading...</span>
        </div>
        <div id="instructions">
            Click & Drag to rotate. Click a marker to play radio.
        </div>
        <button id="pauseButton" title="Play/Pause" disabled>
             <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display: block;"> <path d="M8 5v14l11-7z"/> </svg>
             <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" style="display: none;"> <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/> </svg>
             <div class="loading-spinner"></div>
        </button>
    </div>

    <div id="loadingMessage">Loading Radio Stations...</div>
    <audio id="audioPlayer" crossorigin="anonymous" preload="auto"></audio>

    <script type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Constants ---
        const API_BASE_URL = 'https://at1.api.radio-browser.info/json';
        const GENERAL_STATIONS_URL = `${API_BASE_URL}/stations/search?limit=350&has_geo_info=true&order=random&hidebroken=true&codec=MP3&codec=AAC`;
        const JAPAN_STATIONS_URL = `${API_BASE_URL}/stations/search?limit=50&countrycode=JP&has_geo_info=true&hidebroken=true&codec=MP3&codec=AAC`;
        const GLOBE_RADIUS = 5;
        const FFT_SIZE = 1024;
        const VISUALIZER_HEIGHT = 150;

        // --- DOM Elements ---
        const container = document.getElementById('container');
        const audioPlayer = document.getElementById('audioPlayer');
        const infoBox = document.getElementById('infoBox');
        const stationNameElement = document.getElementById('stationName');
        const loadingMessage = document.getElementById('loadingMessage');
        const pauseButton = document.getElementById('pauseButton');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const loadingSpinner = pauseButton.querySelector('.loading-spinner');
        const visualizerCanvas = document.getElementById('visualizerCanvas');
        const visualizerCtx = visualizerCanvas.getContext('2d');

        // --- Three.js Variables ---
        let scene, camera, renderer, controls;
        let globe, markersGroup;
        const raycaster = new THREE.Raycaster(); const pointer = new THREE.Vector2();
        let INTERSECTED; let selectedMarker = null;

        // --- Web Audio API Variables ---
        let audioContext; let analyser; let audioSource; let dataArray;
        let isAudioContextSetup = false; let lastCorsWarningTime = 0;

        // --- State ---
        let rafId;

        //========================================== Initialization ==========================================
        async function init() {
            console.log("Starting initialization...");
            loadingMessage.style.display = 'block';

            try {
                setupScene();
                setupLighting();
                setupControls();
                setupGlobe();
                setupMarkersGroup();
                setupEventListeners();

                const allStations = await fetchAllStations();
                console.log(`Fetched ${allStations.length} stations total.`);

                if (allStations.length > 0) {
                    addStationMarkers(allStations);
                    console.log("Added station markers.");
                } else {
                     console.warn("No stations loaded or fetch failed.");
                     loadingMessage.textContent = 'No valid stations found.';
                }

                loadingMessage.style.display = 'none';
                animate();

            } catch (error) {
                console.error("Error during initialization:", error);
                loadingMessage.textContent = 'Initialization Error. Please refresh.';
                loadingMessage.style.display = 'block';
            }
        }

        //========================================== Scene Setup ==========================================
        function setupScene() {
            scene = new THREE.Scene(); scene.background = null;
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 15;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio);
            renderer.domElement.id = 'threeCanvas'; container.appendChild(renderer.domElement);
            visualizerCanvas.width = window.innerWidth; visualizerCanvas.height = VISUALIZER_HEIGHT;
        }

        //========================================== Lighting Setup ==========================================
        function setupLighting() {
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xaaaaaa, 1.5 ); scene.add( hemiLight );
            const ambientLight = new THREE.AmbientLight( 0xffffff, 1.0 ); scene.add( ambientLight );
        }

        //========================================== Controls Setup ==========================================
        function setupControls() {
             controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.dampingFactor = 0.05;
             controls.screenSpacePanning = false; controls.enablePan = false; controls.minDistance = 7; controls.maxDistance = 50; controls.maxPolarAngle = Math.PI;
        }

        //========================================== Globe Setup ==========================================
        function setupGlobe() {
            const globeGeometry = new THREE.SphereGeometry(GLOBE_RADIUS, 64, 32);
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js/examples/textures/planets/earth_atmos_2048.jpg',
               () => console.log("Globe texture loaded successfully."),
               undefined,
               (err) => console.error('Failed to load globe texture:', err)
            );
            earthTexture.colorSpace = THREE.SRGBColorSpace;
            const globeMaterial = new THREE.MeshStandardMaterial({ map: earthTexture, metalness: 0.1, roughness: 0.9, color: 0xffffff });
            globe = new THREE.Mesh(globeGeometry, globeMaterial);
            scene.add(globe);
        }

        //========================================== Markers Group Setup ==========================================
        function setupMarkersGroup() { markersGroup = new THREE.Group(); globe.add(markersGroup); }

        //========================================== Event Listeners Setup ==========================================
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize); 
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('click', onClick); 
            window.addEventListener('touchstart', onTouchStart, { passive: true });
            window.addEventListener('contextmenu', (event) => event.preventDefault());
            pauseButton.addEventListener('click', togglePlayback); 
            audioPlayer.addEventListener('error', handleAudioError);
            audioPlayer.addEventListener('stalled', handleAudioStalled); 
            audioPlayer.addEventListener('playing', handleAudioPlaying);
            audioPlayer.addEventListener('pause', handleAudioPaused); 
            audioPlayer.addEventListener('ended', handleAudioEnded);
        }

        function onTouchStart() {
            // This helps iOS recognize the page as touch-enabled
            window.removeEventListener('touchstart', onTouchStart);
        }

        //========================================== Fetch Stations ==========================================
        async function fetchAllStations() {
             console.log("Fetching general and Japanese stations...");
             try {
                 const [generalResponse, japanResponse] = await Promise.all([
                     fetch(GENERAL_STATIONS_URL, { mode: 'cors' }),
                     fetch(JAPAN_STATIONS_URL, { mode: 'cors' })
                 ]);
                 const generalData = generalResponse.ok ? await generalResponse.json() : [];
                 if (!generalResponse.ok) console.warn(`General stations fetch failed: ${generalResponse.status}`);
                 const japanData = japanResponse.ok ? await japanResponse.json() : [];
                 if (!japanResponse.ok) console.warn(`Japan stations fetch failed: ${japanResponse.status}`);

                 console.log(`Fetched ${generalData.length} general, ${japanData.length} Japanese stations raw.`);
                 const allStationsData = [...generalData, ...japanData];
                 const stationMap = new Map();
                 allStationsData.forEach(station => {
                     const url = station.url_resolved || station.url;
                     if (station.geo_lat != null && station.geo_long != null && typeof station.geo_lat === 'number' && typeof station.geo_long === 'number' && url && url.startsWith('https')) {
                         const key = station.stationuuid || url;
                         if (!stationMap.has(key)) {
                             stationMap.set(key, { 
                                 name: (station.name || 'Unknown').replace(/</g, "&lt;").replace(/>/g, "&gt;"), 
                                 lat: station.geo_lat, 
                                 lon: station.geo_long, 
                                 url: url, 
                                 country: (station.countrycode || station.country || 'Unknown').replace(/</g, "&lt;").replace(/>/g, "&gt;"), 
                                 favicon: station.favicon || null, 
                                 codec: station.codec || 'Unknown' 
                             });
                         }
                     }
                 });
                 const uniqueStations = Array.from(stationMap.values());
                 console.log(`Processed ${uniqueStations.length} unique valid HTTPS stations.`);
                 logRegionalDistribution(uniqueStations); 
                 return uniqueStations;
             } catch (error) { 
                 console.error("Failed to fetch stations inside fetchAllStations:", error); 
                 return []; 
             }
        }

        //========================================== Add Station Markers ==========================================
        function addStationMarkers(stationsData) {
             if (!markersGroup) {
                 console.error("markersGroup not initialized before addStationMarkers!");
                 return;
             }
             const markerGeometry = new THREE.SphereGeometry(0.07, 12, 6); 
             const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00, toneMapped: false });
             stationsData.forEach(station => {
                 const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone()); 
                 const phi = (90 - station.lat) * (Math.PI / 180); 
                 const theta = (station.lon + 180) * (Math.PI / 180);
                 marker.position.set(-(GLOBE_RADIUS * Math.sin(phi) * Math.cos(theta)), GLOBE_RADIUS * Math.cos(phi), GLOBE_RADIUS * Math.sin(phi) * Math.sin(theta));
                 marker.position.multiplyScalar(1.01); 
                 marker.lookAt(globe.position); 
                 marker.userData = station; 
                 markersGroup.add(marker);
             }); 
             console.log(`Added ${markersGroup.children.length} markers to markersGroup.`);
        }

        //========================================== Web Audio API Setup ==========================================
        function setupAudioContext() {
             if (isAudioContextSetup) return; 
             try {
                 console.log("Setting up Audio Context..."); 
                 audioContext = new (window.AudioContext || window.webkitAudioContext)();
                 analyser = audioContext.createAnalyser(); 
                 analyser.fftSize = FFT_SIZE;
                 const bufferLength = analyser.frequencyBinCount; 
                 dataArray = new Uint8Array(bufferLength);
                 audioSource = audioContext.createMediaElementSource(audioPlayer); 
                 audioSource.connect(analyser); 
                 analyser.connect(audioContext.destination);
                 isAudioContextSetup = true; 
                 console.log("Audio Context setup complete.");
             } catch (e) { 
                 console.error("Audio Context Error:", e); 
                 alert("Web Audio API init failed."); 
             }
        }

        //========================================== Event Handlers ==========================================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            visualizerCanvas.width = window.innerWidth; 
            visualizerCanvas.height = VISUALIZER_HEIGHT;
        }

        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1; 
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera); 
            const intersects = raycaster.intersectObjects(markersGroup.children);
            if (intersects.length > 0) { 
                const firstIntersect = intersects[0].object; 
                if (INTERSECTED !== firstIntersect) { 
                    if (INTERSECTED && INTERSECTED !== selectedMarker) INTERSECTED.material.color.setHex(0xffcc00); 
                    INTERSECTED = firstIntersect; 
                    if (INTERSECTED !== selectedMarker) INTERSECTED.material.color.setHex(0x00ff00); 
                    document.body.style.cursor = 'pointer'; 
                } 
            }
            else { 
                if (INTERSECTED && INTERSECTED !== selectedMarker) INTERSECTED.material.color.setHex(0xffcc00); 
                INTERSECTED = null; 
                document.body.style.cursor = 'default'; 
            }
        }

        async function onClick(event) {
            // Only proceed if this is a primary click (not right-click)
            if (event.button !== 0) return;
            
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(markersGroup.children);
            
            if (intersects.length > 0) {
                const clickedMarker = intersects[0].object;
                
                // iOS-specific audio context handling
                const handlePlayback = async () => {
                    try {
                        showLoadingState();
                        
                        if (!isAudioContextSetup) {
                            setupAudioContext();
                            // iOS requires we resume the context immediately after creation
                            await audioContext.resume();
                        } else if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                        
                        if (clickedMarker === selectedMarker) {
                            togglePlayback();
                            return;
                        }
                        
                        if (selectedMarker) {
                            selectedMarker.material.color.setHex(0xffcc00);
                            selectedMarker.scale.set(1, 1, 1);
                        }
                        
                        selectedMarker = clickedMarker;
                        selectedMarker.material.color.setHex(0xff0000);
                        const station = selectedMarker.userData;
                        
                        console.log(`Playing: ${station.name} (${station.country}), URL: ${station.url}`);
                        stationNameElement.textContent = `${station.name} (${station.country}) - Loading...`;
                        infoBox.style.display = 'block';
                        
                        audioPlayer.src = station.url;
                        audioPlayer.load();
                        
                        const playPromise = audioPlayer.play();
                        
                        if (playPromise !== undefined) {
                            playPromise
                                .then(() => {
                                    console.log("Playback initiated");
                                    hideLoadingState();
                                })
                                .catch(error => {
                                    console.error("Play() failed:", error);
                                    hideLoadingState();
                                    // Show user-friendly error message
                                    stationNameElement.textContent = `${station.name} - Tap to try again`;
                                    if (selectedMarker) {
                                        selectedMarker.material.color.setHex(0xffcc00);
                                        selectedMarker.scale.set(1, 1, 1);
                                        selectedMarker = null;
                                    }
                                    updatePauseButton();
                                });
                        }
                    } catch (error) {
                        console.error("Playback error:", error);
                        hideLoadingState();
                        stationNameElement.textContent = `Error: ${selectedMarker?.userData?.name || 'station'} - Tap to retry`;
                        if (selectedMarker) {
                            selectedMarker.material.color.setHex(0xffcc00);
                            selectedMarker.scale.set(1, 1, 1);
                            selectedMarker = null;
                        }
                        updatePauseButton();
                    }
                };
                
                // Execute the playback handler
                handlePlayback();
            }
        }

        function showLoadingState() {
            pauseButton.disabled = true;
            playIcon.style.display = 'none';
            pauseIcon.style.display = 'none';
            loadingSpinner.style.display = 'block';
        }

        function hideLoadingState() {
            loadingSpinner.style.display = 'none';
            updatePauseButton();
        }

        async function togglePlayback() {
            if (!selectedMarker) return;
            
            try {
                if (audioPlayer.paused) {
                    showLoadingState();
                    if (audioContext && audioContext.state === 'suspended') {
                        await audioContext.resume();
                    }
                    await audioPlayer.play();
                    hideLoadingState();
                } else {
                    audioPlayer.pause();
                }
            } catch (error) {
                console.error("Toggle playback error:", error);
                hideLoadingState();
                handleAudioError(error);
            }
        }

        function updatePauseButton() {
            if (!selectedMarker) { 
                pauseButton.disabled = true; 
                playIcon.style.display = 'block'; 
                pauseIcon.style.display = 'none'; 
                return; 
            }
            pauseButton.disabled = false; 
            if (audioPlayer.paused) { 
                playIcon.style.display = 'block'; 
                pauseIcon.style.display = 'none'; 
                pauseButton.title = "Play"; 
            } else { 
                playIcon.style.display = 'none'; 
                pauseIcon.style.display = 'block'; 
                pauseButton.title = "Pause"; 
            }
        }

        function handleAudioError(e) {
             console.error('Audio Error:', e); 
             const currentStationName = selectedMarker?.userData?.name || 'station'; 
             let errorDetails = 'Stream offline/incompatible.';
             
             if (audioPlayer.error) { 
                 switch (audioPlayer.error.code) { 
                     case MediaError.MEDIA_ERR_ABORTED: errorDetails = 'Aborted.'; break; 
                     case MediaError.MEDIA_ERR_NETWORK: errorDetails = 'Network error.'; break; 
                     case MediaError.MEDIA_ERR_DECODE: errorDetails = 'Decode error.'; break; 
                     case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorDetails = 'Format/blocked (CORS?).'; break; 
                     default: errorDetails = `Unknown (${audioPlayer.error.code}).`; 
                 } 
             }
             
             // Special handling for iOS
             if (e.message && (e.message.includes('not allowed') || e.message.includes('user gesture'))) {
                 errorDetails = "Tap the station again to play";
             }
             
             const codecInfo = selectedMarker?.userData?.codec ? ` (${selectedMarker.userData.codec})` : ''; 
             stationNameElement.textContent = `Error: ${currentStationName}${codecInfo}. ${errorDetails}`; 
             infoBox.style.display = 'block';
             
             if (selectedMarker) { 
                 selectedMarker.material.color.setHex(0xffcc00); 
                 selectedMarker.scale.set(1, 1, 1); 
                 selectedMarker = null; 
             } 
             updatePauseButton();
        }

        function handleAudioStalled() { 
            console.warn('Audio stalled'); 
            if (selectedMarker) { 
                stationNameElement.textContent = `Buffering: ${selectedMarker.userData.name} (${selectedMarker.userData.country})`; 
                infoBox.style.display = 'block'; 
            } 
        }

        function handleAudioPlaying() { 
            console.log('Audio playing'); 
            if (selectedMarker) { 
                stationNameElement.textContent = `${selectedMarker.userData.name} (${selectedMarker.userData.country})`; 
                infoBox.style.display = 'block'; 
            } 
            updatePauseButton(); 
        }

        function handleAudioPaused() { 
            console.log('Audio paused'); 
            updatePauseButton(); 
        }

        function handleAudioEnded() { 
            console.log('Audio ended'); 
            if (selectedMarker) { 
                selectedMarker.material.color.setHex(0xffcc00); 
                selectedMarker.scale.set(1, 1, 1); 
                selectedMarker = null; 
            } 
            stationNameElement.textContent = 'Stream ended.'; 
            infoBox.style.display = 'block'; 
            updatePauseButton(); 
        }

        //========================================== Animation Loop & Visualization ==========================================
        function animate() {
            rafId = requestAnimationFrame(animate);

            controls.update();

            if (selectedMarker && !audioPlayer.paused) { 
                const time = Date.now() * 0.005; 
                const scaleFactor = 0.15 * Math.abs(Math.sin(time)); 
                selectedMarker.scale.set(1 + scaleFactor, 1 + scaleFactor, 1 + scaleFactor); 
            }
            else if (selectedMarker && selectedMarker.scale.x !== 1) { 
                selectedMarker.scale.set(1, 1, 1); 
            }

            drawVisualizer();

            try {
                 renderer.render(scene, camera);
            } catch (renderError) {
                 console.error("Error during render:", renderError);
            }
        }

        function drawVisualizer() {
            if (!isAudioContextSetup || !analyser) { 
                visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height); 
                return; 
            }
             visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            if (audioPlayer.paused) { return; }
            analyser.getByteTimeDomainData(dataArray);
            let isFlat = true; 
            for(let i = 0; i < analyser.frequencyBinCount; i++) { 
                if (dataArray[i] !== 128) { 
                    isFlat = false; 
                    break; 
                } 
            }
            if (isFlat && Date.now() - lastCorsWarningTime > 10000) { 
                console.warn("Visualizer data flat (CORS?)."); 
                lastCorsWarningTime = Date.now(); 
            }
            const sliceWidth = visualizerCanvas.width * 1.0 / analyser.frequencyBinCount; 
            const canvasHeight = visualizerCanvas.height; 
            const centerY = canvasHeight / 2;
            const offsets = [-15, 0, 15]; 
            const colors = ['rgba(0, 220, 255, 0.3)', 'rgba(59, 130, 246, 0.9)', 'rgba(0, 220, 255, 0.3)']; 
            const lineWidths = [1, 2, 1];
            for(let lineIndex = 0; lineIndex < offsets.length; lineIndex++) {
                visualizerCtx.lineWidth = lineWidths[lineIndex]; 
                visualizerCtx.strokeStyle = colors[lineIndex]; 
                visualizerCtx.beginPath(); 
                let x = 0;
                for (let i = 0; i < analyser.frequencyBinCount; i++) {
                    const v = dataArray[i] / 128.0; 
                    const y = (v * centerY / 2) + centerY + offsets[lineIndex];
                    if (i === 0) visualizerCtx.moveTo(x, y); 
                    else visualizerCtx.lineTo(x, y);
                    x += sliceWidth;
                }
                visualizerCtx.lineTo(visualizerCanvas.width, centerY + offsets[lineIndex]); 
                visualizerCtx.stroke();
            }
        }

        //========================================== Utility Functions ==========================================
        function logRegionalDistribution(stations) {
             const regions = { Africa: 0, Asia: 0, Europe: 0, NorthAmerica: 0, SouthAmerica: 0, Oceania: 0, Other: 0, Japan: 0 };
             stations.forEach(s => {
                 if (s.country === 'JP') regions.Japan++;
                 else if (s.lon > -20 && s.lon < 60 && s.lat > -40 && s.lat < 40) regions.Africa++;
                 else if (s.lon > 60 && s.lon < 180 && s.lat > -10) regions.Asia++;
                 else if (s.lon > -10 && s.lon < 40 && s.lat > 35) regions.Europe++;
                 else if (s.lon > -170 && s.lon < -50 && s.lat > 10) regions.NorthAmerica++;
                 else if (s.lon > -90 && s.lon < -30 && s.lat < 10) regions.SouthAmerica++;
                 else if (s.lon > 110 && s.lon < 180 && s.lat < -10) regions.Oceania++;
                 else regions.Other++;
             });
             console.log("Approximate regional distribution:", regions);
        }

        //========================================== Start Application ==========================================
        init();
    </script>
</body>
</html>
